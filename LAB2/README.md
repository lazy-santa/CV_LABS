# **Лаборатораня работа №2**

## Задание
Нужно построить траекторию движения камеры по нескольким изображениям одного объекта (со смещением), выполнив следующие пункты:
- Определите на каждой фотографии ключевые точки (например, углы)
- Постройте по каждой точке дескриптор (можете использовать любой, рекомендуется SIFT)
- Сопоставьте два соседних изображения на предмет соответствия ключевых точек (дискрипторов)
- Постройте модель преобразования изображений, учитывайте только поворот и сдвиг
- С учетом полученных моделей постройте траекторию движения камеры

### Файл лабораторной работы с реализованными функциями: [CV_LAB2.ipynb](CV_LAB2.ipynb)

### Исходные изображения: 

![Без имени](https://github.com/user-attachments/assets/5fadd0e9-c4ad-4566-9d99-eeabcd83f21a)
![Без имени-1](https://github.com/user-attachments/assets/54352383-bc16-49f8-b72a-87ab0fde96db)
![Без имени](https://github.com/user-attachments/assets/dcd56b3d-3a17-4c8d-926e-d9228dd830e4)


*Для ускорения вычислений размер исходных изображений был уменьшен до (600, 800), для этого был использован метод cv2.resize().
**Исходные изображения были переведены в оттенки серого, для этого был использован метод cv2.cvtColor(image, cv2.COLOR_RGB2GRAY).

## Детектор Харриса
Детектор углов Харриса  — это алгоритм обнаружения ключевых точек (углов) в изображении, разработанный Кристофером Харрисом и Майком Стефенсом в 1988 году. Он широко используется в компьютерном зрении для задач, таких как сопоставление изображений, трекинг объектов и 3D-реконструкция. Основная идея метода заключается в поиске точек, где наблюдается значительное изменение яркости в двух перпендикулярных направлениях (углы).

Харрис и Стефенс улучшили детектор Моравеца (Moravec), введя анизотропию по всем направлениям, т.е. рассматривают производные яркости изображения для исследования изменений яркости по множеству направлений. Они вводят в рассмотрение производные по некоторым принципиальным направлениям.

**Детектор Моравеца** – самый простой из существующих. Автор рассматривает изменение яркости квадратного окна W (обычно размера 3х3, 5х5, 7х7 пикселей) относительно интересующей точки при сдвиге окна W на 1 пиксель в 8-ми направлениях (горизонтальных, вертикальных и диагональных).

Взвешенная сумма квадрата разностей:

![image.png](https://habrastorage.org/r/w1560/files/68b/9ce/118/68b9ce1189b34b698309a7d70414a913.png)

где w(x,y) – весовая функция (обычно используется функция Гаусса или бинарное окно).

![image.png](https://habrastorage.org/r/w1560/files/b06/ae8/34c/b06ae834c0c34fa588961baa95fa8610.png)

![image.png](https://habrastorage.org/files/a29/58a/acb/a2958aacbe3b49feae98047cf8f9cd69.png)
где M – автокорреляционная матрица 

Угол характеризуется большими изменениями функции E(x,y) по всем возможным направлениям (x,y), что эквивалентно большим по модулю собственным значениям матрицы M. Расположение собственных значений приведено на следующем рисунке.
![image.png](https://habrastorage.org/r/w1560/files/487/859/f3d/487859f3d0e6455cb2b62baad30220c1.png)

Поскольку напрямую считать собственные значения является трудоёмкой задачей, Харрисом и Стефеном была предложена мера отклика:
![image.png](https://habrastorage.org/r/w1560/files/fe8/119/9a8/fe81199a88d1413b98123860db3d37a9.png)

где k – эмпирическая константа, ***k∈[0.04;0.06]***

***det(M)*** - модуль матрицы М; 

***tr(M)*** - сумма собственных чисел матрицы М.

Таким образом, значение R положительно для угловых особых точек. Затем производится отсечение точек по найденному порогу R (порог берется в пределах [0;1]). Точки у которых значение R меньше порога, исключаются из рассмотрения.

Ссылка на статью про детектор углов: https://habr.com/ru/articles/244541/

Преимущества метода:
- Инвариантность к поворотам  изображения
- Высокая чувствительность к углам и краям
- Быстрое вычисление благодаря использованию свёрток
     
Ограничения: 
- Чувствителен к масштабированию  (углы могут исчезать при изменении масштаба)    

### Результат работы детектора Харриса
<img src="https://github.com/user-attachments/assets/efb7a3ee-a2de-4a14-a509-c2157a36c056" width="400" />
<img src="https://github.com/user-attachments/assets/06538a98-bc94-4929-ae2b-405ef56f5bc0" width="400" />

## Дескриптор SIFT

**Дескриптор** – это идентификатор особой точки, выделяющий её из остального множества особых точек. В свою очередь, дескрипторы должны обеспечивать инвариантность нахождения соответствия между особыми точками относительно преобразований изображений.

Источник статьи про SIFT: https://habr.com/ru/articles/106302/

SIFT (Scale-Invariant Feature Transform)  — это алгоритм компьютерного зрения, разработанный Дэвидом Лоу (David Lowe) в 1999 году. Он предназначен для обнаружения и описания ключевых точек (interest points)  на изображении, которые инвариантны к изменениям масштаба, поворота, освещения и частично — к аффинным преобразованиям. 

В методе SIFT дескриптором является вектор. Как и направление ключевой точки, дескриптор вычисляется на гауссиане, ближайшем по масштабу к ключевой точке, и исходя из градиентов в некотором окне ключевой точки. Перед вычислением дескриптора это окно поворачивают на угол направления ключевой точки, чем и достигается инвариантность относительно поворота.

![image.png](https://habrastorage.org/r/w780/storage/habraeffect/fe/6b/fe6b57079b5e7a2f195173ad982ecccc.png)

Преимущества SIFT:
- Инвариантность к масштабу и повороту
- Устойчивость к изменениям освещения и частично — к аффинным искажениям
- Высокая точность сопоставления     

Ограничения SIFT:
- Вычислительная сложность – Построение масштабируемого пространства и дескрипторов требует значительных ресурсов
- Патенты – Алгоритм был запатентован, что ограничивало его использование в коммерческих проектах до истечения срока действия патентов (в 2020 году).
- Не все полученные точки и их дескрипторы будут отвечать предъявляемым требованиям. В некоторых случаях решение может быть не найдено, даже если оно существует
     
## Нахождение соответствий
Для нахождения соответствий между парами ключевых точек используется так называемый тест Девида Лоу. 

Сопоставление признаков осуществляется с помощью подхода, основанного на евклидовом расстоянии до ближайшего соседа. Для увеличения устойчивости сопоставление отбрасывается для ключевых точек, для которых отношение расстояния до ближайшего соседа к расстоянию до второго ближайшего соседа больше 0,8. Это отбрасывает много ложных соответствий, возникающих из фоновых мешающих изображений. 

Алгоритм сопоставления:
  1. Вычисление Евклидова расстояния
  Используется формула Евклидова расстояния:

  ![image.png](https://ic.pics.livejournal.com/yu_xuan/12681078/223220/223220_original.png)
 
  2. Сортировка расстояний: Расстояния сортируются по возрастанию, чтобы найти два ближайших соседа.
Если расстояние до ближайшего соседа значительно меньше, чем расстояние до второго ближайшего соседа, то соответствие считается хорошим.

### Результат сопоставления точек (точки соединены прямыми):

<img src="https://github.com/user-attachments/assets/5a420a53-a84f-44b3-8ab2-244aba061681" width="800" />

## Оценка трансформаций

1. Для каждой пары соответствующих между собой точек преобразуем их в координаты.
2. Находим центры масс для обоих наборов точек. Вычитаем центры масс из координат точек. Это необходимо, чтобы устранить влияние сдвига при вычислении поворота.
3. Вычесляем матрицу ковариации H как произведение центрированных точек.
4. Выполняем сингулярное разложение матрицы ковариации. Разложение по сингулярным числам используется для нахождения матрицы поворота R.
5. Угол поворота вычисляется из матрицы R. Матрица поворота получается как произведение транспонированных матриц из SVD.
6. Вектор сдвига вычисляется как разница между центрами масс после применения поворота.
7. Создаем матрицу преобразования размером 2x3:
  - В левой части 2x2 записываем матрицу поворота
  - В правом столбце записываем вектор сдвига

### Траектория движения камеры
<img src="https://github.com/user-attachments/assets/1cfd1f9f-5b0c-4b25-ac5d-6b3cd7b9edb2" width="500" />
