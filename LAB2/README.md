# **Лаборатораня работа №2**

## Задание
Нужно построить траекторию движения камеры по нескольким изображениям одного объекта (со смещением), выполнив следующие пункты:
- Определите на каждой фотографии ключевые точки.
- Отфильтровать лучшие изображения, обработать изображения.
- Постройте по каждой точке дескриптор (можете использовать любой, рекомендуется SIFT)
- Сопоставьте два соседних изображения на предмет соответствия ключевых точек.
- Постройте модель преобразования изображений, учитывайте только поворот и сдвиг.
- С учетом полученных моделей постройте траекторию движения камеры.

Разрешается использовать методы из *cv2*. Справочная информация в *OpenCV.docs*.

## Ход работы

Файл лабораторной работы с реализованными функциями - [CV_LAB2.ipynb](CV_LAB2.ipynb)

Исходное изображение 

![photo_1.jpg](photo_1.jpg)
![photo_2.jpg](photo_1.jpg)
![photo_3.jpg](photo_1.jpg)

Для ускорения вычислений и работы кода размер исходных изображений был уменьшен, для этого был использован метод cv2.resize().

## Выравнивание яркости

Для выравнивания яркости изображения выберем эталонное изображение , рассчитаем его среднее значение яркости и стандартное отклонение. Такие же расчеты сделаем для выбранного изображения. После чего используем метод **линейной трансформации яркости**.

Его суть в том, чтобы среднее значение и стандартное отклонение выбранного изображения стали равны эталонному.

## Детектор Харриса

Харрис и Стефенс улучшили детектор Моравеца (Moravec), введя анизотропию по всем направлениям, т.е. рассматривают производные яркости изображения для исследования изменений яркости по множеству направлений. Они вводят в рассмотрение производные по некоторым принципиальным направлениям.

**Детектор Моравеца** – самый простой из существующих. Автор рассматривает изменение яркости квадратного окна W (обычно размера 3х3, 5х5, 7х7 пикселей) относительно интересующей точки при сдвиге окна W на 1 пиксель в 8-ми направлениях (горизонтальных, вертикальных и диагональных).

Взвешенная сумма квадрата разностей:
![image.png](https://habrastorage.org/r/w1560/files/68b/9ce/118/68b9ce1189b34b698309a7d70414a913.png)

где w(x,y) – весовая функция (обычно используется функция Гаусса или бинарное окно).

![image.png](https://habrastorage.org/r/w1560/files/b06/ae8/34c/b06ae834c0c34fa588961baa95fa8610.png)

M – автокорреляционная матрица:

![image.png](https://habrastorage.org/files/a29/58a/acb/a2958aacbe3b49feae98047cf8f9cd69.png)

Угол характеризуется большими изменениями функции E(x,y) по всем возможным направлениям (x,y), что эквивалентно большим по модулю собственным значениям матрицы M. Расположение собственных значений приведено на следующем рисунке.
![image.png](https://habrastorage.org/r/w1560/files/487/859/f3d/487859f3d0e6455cb2b62baad30220c1.png)

Поскольку напрямую считать собственные значения является трудоёмкой задачей, Харрисом и Стефеном была предложена мера отклика:
![image.png](https://habrastorage.org/r/w1560/files/fe8/119/9a8/fe81199a88d1413b98123860db3d37a9.png)

где k – эмпирическая константа, ![image.png](https://habrastorage.org/r/w1560/files/0bb/4e2/9df/0bb4e29dfed948d6bab28aee61fc366a.png)

***det(M)*** - модуль матрицы М; ***tr(M)*** - сумма собственных чисел матрицы М.

Таким образом, значение R положительно для угловых особых точек. Затем производится отсечение точек по найденному порогу R (т.е. те точки, у которых значение R меньше некоторого порога, исключаются из рассмотрения).

Ссылка на статью: https://habr.com/ru/articles/244541/

![image_with_points.png](image_with_points.png)

## Дескриптор SIFT

**Дескриптор** – идентификатор особой точки, выделяющий её из остального множества особых точек. В свою очередь, дескрипторы должны обеспечивать инвариантность нахождения соответствия между особыми точками относительно преобразований изображений.

Источник: https://habr.com/ru/articles/106302/

В методе SIFT дескриптором является вектор. Как и направление ключевой точки, дескриптор вычисляется на гауссиане, ближайшем по масштабу к ключевой точке, и исходя из градиентов в некотором окне ключевой точки. Перед вычислением дескриптора это окно поворачивают на угол направления ключевой точки, чем и достигается инвариантность относительно поворота.

![image.png](https://habrastorage.org/r/w780/storage/habraeffect/fe/6b/fe6b57079b5e7a2f195173ad982ecccc.png)

SIFT дескрипторы не лишены недостатков. Не все полученные точки и их дескрипторы будут отвечать предъявляемым требованиям. Естественно это будет сказываться на дальнейшем решении задачи сопоставления изображений. В некоторых случаях решение может быть не найдено, даже если оно существует.

## Нахождение соответствий

1. Вычисление Евклидова расстояния
Используется формула Евклидова расстояния:

![image.png](https://ic.pics.livejournal.com/yu_xuan/12681078/223220/223220_original.png)
 
2. Сортировка расстояний :
Расстояния сортируются по возрастанию, чтобы найти два ближайших соседа (тест Лоу)
Если расстояние до ближайшего соседа (m_distance) значительно меньше, чем расстояние до второго ближайшего соседа (n_distance), то соответствие считается хорошим.

![match_draw.png](match_draw.png)

## Оценка трансформаций

1. Для каждой пары соответствий из matches извлекаются координаты ключевых точек из keypoints1 и keypoints2.
2. Точки центрируются относительно их центров масс, чтобы устранить влияние сдвига при вычислении поворота.
3. Матрица ковариации H вычисляется как произведение центрированных точек.
4. Разложение по сингулярным числам используется для нахождения матрицы поворота R, которая минимизирует ошибку между точками.
5. Угол поворота вычисляется из матрицы R. Вектор сдвига вычисляется как разница между центрами масс после применения поворота.
6. Матрица преобразования объединяет поворот (R) и сдвиг (t).

![trajectory.png](trajectory.png)